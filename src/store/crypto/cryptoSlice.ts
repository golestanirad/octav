import { createSlice } from "@reduxjs/toolkit";
import {
  fetchCoinDetails,
  fetchCoinHistory,
  fetchCoinRanking,
  fetchNews,
  fetchOctavData,
} from "./cryptoAPI";
import { Coin, CoinDetails, History, News, Stats } from "../../app/types";
import { messages } from "../../app/constants";

//// types
export interface CryptoState {
  coins: Coin[];
  favoriteCoins: string[];
  stats: Stats;
  selectedCoinDetails: CoinDetails | null;
  selectedCoinHistory: History[] | null;
  news: News[] | null;
  error: string;
  loadings: {
    isLoadingCoins: boolean;
    isLoadingCoinDetails: boolean;
    isLoadingHistory: boolean;
    isLoadingNews: boolean;
    isLoadingOctav: boolean;
  };
  octav: any;
}

//// initial state
const initialState: CryptoState = {
  coins: [],
  favoriteCoins: [],
  stats: {
    total: 0,
    totalCoins: 0,
    totalMarkets: 0,
    totalExchanges: 0,
    totalMarketCap: "",
    total24hVolume: "",
  },
  selectedCoinDetails: null,
  selectedCoinHistory: null,
  news: null,
  error: "",
  loadings: {
    isLoadingCoins: false,
    isLoadingCoinDetails: false,
    isLoadingHistory: false,
    isLoadingNews: false,
    isLoadingOctav: false,
  },
  octav: null,
};

/// slice
export const cryptoSlice = createSlice({
  name: "crypto",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    toggleFavorite: (state, action) => {
      const favoriteCoins = state.favoriteCoins;
      const isItAleadyFavorite = favoriteCoins.find(
        (fc) => fc === action.payload
      );
      if (isItAleadyFavorite) {
        /// we remove it from favorite list if it already exsit
        state.favoriteCoins = favoriteCoins.filter(
          (fc) => fc !== action.payload
        );
      } else {
        state.favoriteCoins.push(action.payload);
      }
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      //// fetchOctavData
      .addCase(fetchOctavData.pending, (state) => {
        state.loadings.isLoadingOctav = true;
      })
      .addCase(fetchOctavData.fulfilled, (state, action) => {
        state.loadings.isLoadingOctav = false;
        state.octav = action.payload;
      })
      .addCase(fetchOctavData.rejected, (state, action) => {
        state.error = action.error.message || messages.rejectedFetchError;
        state.loadings.isLoadingOctav = true;
      })
      //// fetchCoinRanking
      .addCase(fetchCoinRanking.pending, (state) => {
        state.loadings.isLoadingCoins = true;
      })
      .addCase(fetchCoinRanking.fulfilled, (state, action) => {
        state.loadings.isLoadingCoins = false;
        state.coins = action.payload.coins;
        state.stats = action.payload.stats;
      })
      .addCase(fetchCoinRanking.rejected, (state, action) => {
        state.error = action.error.message || messages.rejectedFetchError;
        state.loadings.isLoadingCoins = true;
      })
      //// fetchCoinDetails
      .addCase(fetchCoinDetails.pending, (state) => {
        state.loadings.isLoadingCoinDetails = true;
      })
      .addCase(fetchCoinDetails.fulfilled, (state, action) => {
        state.loadings.isLoadingCoinDetails = false;
        state.selectedCoinDetails = action.payload;
      })
      .addCase(fetchCoinDetails.rejected, (state, action) => {
        state.loadings.isLoadingCoinDetails = false;
        state.error = action.error.message || messages.rejectedFetchError;
      })
      ///// ftech coin history
      .addCase(fetchCoinHistory.pending, (state) => {
        state.loadings.isLoadingHistory = true;
      })
      .addCase(fetchCoinHistory.fulfilled, (state, action) => {
        state.loadings.isLoadingHistory = false;
        state.selectedCoinHistory = action.payload;
      })
      .addCase(fetchCoinHistory.rejected, (state, action) => {
        state.loadings.isLoadingHistory = false;
        state.error = action.error.message || messages.rejectedFetchError;
      })
      ///// ftech news
      .addCase(fetchNews.pending, (state) => {
        state.loadings.isLoadingNews = true;
      })
      .addCase(fetchNews.fulfilled, (state, action) => {
        state.loadings.isLoadingNews = false;
        state.news = action.payload;
      })
      .addCase(fetchNews.rejected, (state, action) => {
        state.loadings.isLoadingNews = false;
        state.error = action.error.message || messages.rejectedFetchError;
      });
  },
});

export const { toggleFavorite } = cryptoSlice.actions;

export default cryptoSlice.reducer;
